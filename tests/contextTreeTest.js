'use strict';

import util from 'util'; // For deep logging
import assert from 'assert/strict'; // For basic assertions

import Db from '../src/index.js'

// --- Test Config ---
const DB_PATH = '/tmp/testdb-context-tree'; // Use a dedicated path

// --- Test Data ---
const noteA = {
    // id: 'note-a-123', // ID should be generated by the system
    schema: 'data/abstraction/note',
    data: { title: 'Note A', content: 'Content for A' }
};
const noteB = {
    // id: 'note-b-456',
    schema: 'data/abstraction/note',
    data: { title: 'Note B', content: 'Content for B' }
};
const tabC = {
    // id: 'tab-c-789',
    schema: 'data/abstraction/tab',
    data: { title: 'Tab C', url: 'https://example.com/c' }
};

// --- Test Setup ---
const db = new Db({
    rootPath: DB_PATH,
})

const capturedEvents = [];

function setupEventListeners(tree) {
    const eventTypes = [
        'tree:path:inserted',
        'tree:path:removed',
        'tree:path:moved',
        'tree:path:copied',
        'tree:path:locked',
        'tree:path:unlocked',
        'tree:document:inserted',
        'tree:document:updated',
        'tree:document:removed',
        'tree:document:deleted'
        // Add batch events if testing those specifically
    ];

    eventTypes.forEach(eventType => {
        tree.on(eventType, (payload) => {
            console.log(`\n<<< Event Received: ${eventType} >>>`);
            console.log(util.inspect(payload, { depth: null, colors: true }));
            capturedEvents.push({ type: eventType, payload });
        });
    });
    console.log('Event listeners set up.');
}

function findEvent(type) {
    return capturedEvents.find(e => e.type === type);
}

function findEvents(type) {
    return capturedEvents.filter(e => e.type === type);
}

function clearEvents() {
    capturedEvents.length = 0;
}

// --- Test Runner ---
async function runTests() {
    console.log(`--- Starting ContextTree Tests (DB: ${DB_PATH}) ---`);

    // Start the main SynapsD instance (asynchronous)
    await db.start();
    console.log('SynapsD DB Started.');

    // Get the tree instance AFTER db is started
    const tree = db.tree;

    // ContextTree initialization might already be handled by db.start() if integrated,
    // but calling it explicitly might still be necessary or harmless.
    // If db.start() handles tree init, this await might resolve immediately.
    await tree.initialize();
    console.log('Tree Initialized (or confirmed initialized).');

    // Setup event listeners on the correct tree instance
    setupEventListeners(tree);

    let noteAId, noteBId; // Variables to store generated IDs

    // --- 1. Path Operations ---
    console.log('\n--- Testing Path Operations ---');
    assert.strictEqual(tree.pathExists('/'), true, 'Test 1.1: Root path should exist');
    assert.strictEqual(tree.pathExists('/nonexistent'), false, 'Test 1.2: Nonexistent path check');

    await tree.insertPath('/work/projectA');
    await tree.insertPath('/work/notes');
    await tree.insertPath('/personal/journal');
    console.log('Initial paths inserted.');
    console.log('Current Paths:', tree.paths);
    assert.strictEqual(tree.pathExists('/work/projectA'), true, 'Test 1.3: Inserted path exists');
    assert.deepStrictEqual(tree.pathToLayerIds('/work/projectA').length, 2, 'Test 1.4: pathToLayerIds count');

    // Move
    await tree.movePath('/work/notes', '/personal');
    console.log('Moved /work/notes to /personal/notes');
    assert.strictEqual(tree.pathExists('/work/notes'), false, 'Test 1.5: Original path after move');
    assert.strictEqual(tree.pathExists('/personal/notes'), true, 'Test 1.6: New path after move');
    assert.ok(findEvent('tree:path:moved'), 'Test 1.7: Move event emitted');
    clearEvents();

    // Copy
    await tree.copyPath('/work/projectA', '/personal', true); // Recursive copy
    console.log('Copied /work/projectA to /personal/projectA');
    assert.strictEqual(tree.pathExists('/work/projectA'), true, 'Test 1.8: Original path after copy');
    assert.strictEqual(tree.pathExists('/personal/projectA'), true, 'Test 1.9: New path after copy');
    assert.ok(findEvent('tree:path:copied'), 'Test 1.10: Copy event emitted');
    clearEvents();

    // Remove
    await tree.removePath('/personal/journal');
    console.log('Removed /personal/journal');
    assert.strictEqual(tree.pathExists('/personal/journal'), false, 'Test 1.11: Path after remove');
    assert.ok(findEvent('tree:path:removed'), 'Test 1.12: Remove event emitted');
    clearEvents();

    // --- 2. Locking Operations ---
    console.log('\n--- Testing Locking Operations ---');
    const lockContext1 = 'editor-session-1';
    const lockContext2 = 'indexer-process';

    await tree.lockPath('/work/projectA', lockContext1);
    console.log(`Path /work/projectA locked by ${lockContext1}`);
    assert.ok(findEvent('tree:path:locked'), 'Test 2.1: Lock event emitted');
    clearEvents();

    // Verify lock (need access to layer object or check via tree methods)
    // Let's try to move it - should fail if layer setName checks lock
    // We need LayerIndex access for direct layer check
    const projectALayer = tree.getLayerForPath('/work/projectA'); // Use public method
    assert.ok(projectALayer, 'Test 2.1a: Layer object should be retrieved for path /work/projecta');
    assert.strictEqual(projectALayer.isLocked, true, 'Test 2.2: Layer isLocked property check');

    // Idempotency check
    await tree.lockPath('/work/projectA', lockContext1);
    assert.strictEqual(findEvent('tree:path:locked'), undefined, 'Test 2.4: Lock event NOT emitted for idempotent lock');

    // Lock by another context
    await tree.lockPath('/work/projectA', lockContext2);
    console.log(`Path /work/projectA locked by ${lockContext2}`);
    assert.ok(findEvent('tree:path:locked'), 'Test 2.5: Second lock event emitted');
    assert.strictEqual(projectALayer.isLockedBy(lockContext2), true, 'Test 2.6: Layer isLockedBy context2');
    clearEvents();

    // Unlock by first context
    let stillLocked = await tree.unlockPath('/work/projectA', lockContext1);
    console.log(`Path /work/projectA unlocked by ${lockContext1}. Still locked IDs:`, stillLocked);
    assert.ok(findEvent('tree:path:unlocked'), 'Test 2.7: Unlock event emitted');
    assert.strictEqual(projectALayer.isLocked, true, 'Test 2.8: Layer still locked after partial unlock');
    assert.strictEqual(projectALayer.isLockedBy(lockContext1), false, 'Test 2.9: Layer NOT locked by context1');
    assert.strictEqual(projectALayer.isLockedBy(lockContext2), true, 'Test 2.10: Layer STILL locked by context2');
    assert.strictEqual(stillLocked.length, 2, 'Test 2.11: unlockPath return value (still locked count)'); // root + work + projecta = 3? No, root isn't part of path slice -> work + projecta = 2
    clearEvents();

    // Unlock by second context
    stillLocked = await tree.unlockPath('/work/projectA', lockContext2);
    console.log(`Path /work/projectA unlocked by ${lockContext2}. Still locked IDs:`, stillLocked);
    assert.ok(findEvent('tree:path:unlocked'), 'Test 2.12: Second unlock event emitted');
    assert.strictEqual(projectALayer.isLocked, false, 'Test 2.13: Layer is unlocked after final unlock');
    assert.strictEqual(projectALayer.isLockedBy(lockContext2), false, 'Test 2.14: Layer NOT locked by context2');
    assert.strictEqual(stillLocked.length, 0, 'Test 2.15: unlockPath return value (empty array)');
    clearEvents();

    // --- 3. Document Operations & Events ---
    console.log('\n--- Testing Document Operations & Events ---');
    const docPath = '/personal/projecta'; // Use normalized path for context spec

    // Insert noteA
    noteAId = await tree.insertDocument(noteA, docPath);
    console.log(`Inserted Note A (ID: ${noteAId}) into ${docPath}`);
    assert.ok(typeof noteAId === 'number' && noteAId > 0, 'Test 3.0: Inserted ID is a positive number');
    let insertEvent = findEvent('tree:document:inserted');
    assert.ok(insertEvent, 'Test 3.1: Insert event emitted');
    assert.strictEqual(insertEvent.payload.documentId, noteAId, 'Test 3.2: Insert event doc ID matches returned ID');
    assert.strictEqual(insertEvent.payload.contextSpec, docPath, 'Test 3.3: Insert event contextSpec (normalized)');
    assert.deepStrictEqual(insertEvent.payload.layerNames, ['personal', 'projecta'], 'Test 3.4: Insert event layerNames');
    clearEvents();

    // Update noteA
    const updatedNoteA = {
        id: noteAId, // Use the generated ID
        schema: noteA.schema,
        data: { ...noteA.data, content: 'Updated Content A' } // Update content
    };
    await tree.updateDocument(updatedNoteA, docPath);
    console.log(`Updated Note A (ID: ${noteAId}) in ${docPath}`);
    let updateEvent = findEvent('tree:document:updated');
    assert.ok(updateEvent, 'Test 3.5: Update event emitted');
    assert.strictEqual(updateEvent.payload.documentId, noteAId, 'Test 3.6: Update event doc ID matches');
    assert.strictEqual(updateEvent.payload.contextSpec, docPath, 'Test 3.7: Update event contextSpec (normalized)');
    assert.deepStrictEqual(updateEvent.payload.layerNames, ['personal', 'projecta'], 'Test 3.8: Update event layerNames');
    clearEvents();

    // Remove noteA (from context)
    await tree.removeDocument(noteAId, docPath);
    console.log(`Removed Note A (ID: ${noteAId}) from context ${docPath}`);
    let removeEvent = findEvent('tree:document:removed');
    assert.ok(removeEvent, 'Test 3.9: Remove event emitted');
    assert.strictEqual(removeEvent.payload.documentId, noteAId, 'Test 3.10: Remove event doc ID matches');
    assert.strictEqual(removeEvent.payload.contextSpec, docPath, 'Test 3.11: Remove event contextSpec (normalized)');
    assert.deepStrictEqual(removeEvent.payload.layerNames, ['personal', 'projecta'], 'Test 3.12: Remove event layerNames');
    clearEvents();

    // Insert noteB to test delete
    noteBId = await tree.insertDocument(noteB, '/work');
    console.log(`Inserted Note B (ID: ${noteBId}) into /work`);
    assert.ok(typeof noteBId === 'number' && noteBId > 0, 'Test 3.12a: Inserted ID is a positive number');
    clearEvents();

    // Delete noteB (physical)
    await tree.deleteDocument(noteBId);
    console.log(`Deleted Note B (ID: ${noteBId}) physically`);
    let deleteEvent = findEvent('tree:document:deleted');
    assert.ok(deleteEvent, 'Test 3.13: Delete event emitted');
    assert.strictEqual(deleteEvent.payload.documentId, noteBId, 'Test 3.14: Delete event doc ID matches');
    assert.strictEqual(deleteEvent.payload.contextSpec, undefined, 'Test 3.15: Delete event no contextSpec');
    assert.strictEqual(deleteEvent.payload.layerNames, undefined, 'Test 3.16: Delete event no layerNames');
    clearEvents();

    // --- 4. Final State ---
    console.log('\n--- Final Tree Structure ---');
    console.log(util.inspect(tree.buildJsonTree(), { depth: null, colors: true }));
    console.log('Final Paths:', tree.paths);

    console.log('\n--- All Tests Passed! --- \n');

}

// --- Run and Cleanup ---
runTests().catch(error => {
    console.error('\n*** TEST FAILED ***');
    console.error(error);
    process.exit(1);
}).finally(async () => {
    // Close the database connection if necessary
    await db.shutdown();
    console.log('DB Shutdown.');
});

